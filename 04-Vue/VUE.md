# VUE 3

## 基础

### 模板语法

文本插值：{{}}

指令 Directives:指令是带有 `v-` 前缀的特殊 attribute。

v-on:submit.prevent="onSubmit"(name-argument-modifiers-value)

### 响应式基础

选项式中：

1.只有写在 `data` 中的数据才是响应式数据，不是在 `data` 中创建的数据将不具备响应式；

2.`$forceUpdate()` 该方法是用来强制渲染组件用的；

3.`computed` 是计算属性选项，计算属性会缓存值，非惰性，一定要有一个 return（计算结果），多个值影响一个值，不支持异步；想要进行修改可以写成对象，配置一个 get 和一个 set 方法；

4.`watch` 是侦听器的选项，侦听器不会缓存值，惰性，不需要返回值，一个值影响多个值，支持异步。

### 生命周期

创建前后，挂载前后，更新前后，卸载前后。重点：*created()*，*mounted()*

### 模板引用

`ref`

选项式中

可以给多个元素添加一个相同的 ref 值，当获取的时候可以获取到一个数组；

也可以设置为一个函数，函数中有一个参数，参数就是元素本身；

如果需要使用 DOM 可以给其添加一个 ref 属性，在事件或者钩子函数 通过 `this.$refs` 进行获取，ref 属性也可以用来标记组件

## 组件

### props

 *`Vue`*中所谓的单向数据流，就是子组件只能使用父组件传递过来的数据，但是不能修改

### v-model

 v-model 都是在组件上使用，会将 `modelValue` 作为 prop传递，并以 `update:modelValue` 作为对应的事件

### 透传

所有的属性都可以进行透传，事件监听也可以进行透传

### 插槽

父元素的内容传到出口位置

slot 就是插槽，可以插入一个标签，插槽一句话介绍就是做内容分发用的；

一个 slot 中可以插入多个标签，如果在一个组件中，需要插入多个内容，而且这些内容的位置是不同的，那么就可以使用具名插槽；

插槽传值也叫作用域插槽，所有的值都会传到 data 中

### 依赖注入

inject 将祖先组件发射的数据，注入到当前组件中(接收)

```js
   inject: ['name']
```

祖先组件中配置提供 依赖（发射值）

```js
   provide(){
            return {
                // return 出去的内容就是要共享的内容
               name: this.name
            }
       }
```

## 应用规模化

### 单文本组件

一个 Vue 单文件组件 (SFC)，通常使用 `*.vue` 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。每一个 `*.vue` 文件都由三种顶层语言块构成：`<template>`、`<script>` 和 `<style>`

<script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。

### 工具链

[Vite](https://cn.vitejs.dev/) 是一个轻量级的、速度极快的构建工具，对 Vue SFC 提供第一优先级支持

### 路由

服务端路由指的是服务器根据用户访问的 URL 路径返回不同的响应结果。

一个客户端路由器的职责就是利用诸如 [History API](https://developer.mozilla.org/en-US/docs/Web/API/History) 或是 [`hashchange` 事件](https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event)这样的浏览器 API 来管理应用当前应该渲染的视图。

### 状态管理

**`Vuex`** 

**`Pinia`**

### 服务端渲染

服务端渲染(ssr)

与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：

- **更快的首屏加载**：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的[核心 Web 指标](https://web.dev/vitals/)评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。
- **统一的心智模型**：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。
- **更好的 SEO**：搜索引擎爬虫可以直接看到完全渲染的页面。